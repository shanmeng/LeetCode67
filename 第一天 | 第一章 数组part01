8/20/2025

算法训练营第一天 | 704. 二分查找, 27. 移除元素, 977. 有序数组的平方

第一天! 第一次刷题, 一定要坚持, 67天之后回见!

文章: 
https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

知识点:
数组是存放在连续内存空间上的相同类型数据的集合
需要两点注意的是:
数组下标都是从0开始的
数组内存空间的地址是连续的
正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址
数组的元素是不能删的，只能覆盖

二维数组在内存的空间地址是连续的么？
不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。在Java中的解释看原文吧.
=============================================================================================

704. 二分查找

例题:
LeetCode 704.
https://leetcode.com/problems/binary-search/description/

思路:
没学之前的看题反应: 从左到右依次跟target值比大小...服了...

学了二分法之后的收获: 
区间边界的处理 —— 左闭右闭[ ] , 左闭右开[ ), 与之相对应的比大小是用 <= 和 >= 还是用 < 和 >. 
对开闭区间理解清楚了, 在比大小的时候脑子就不捣糨糊了, 不用再重复比较已经比较过的值了, 对于已经比较过的值, 记得在划新区间的时候把它刨除不然就又要在新区间里再比较一次.
当然, 怎么刨除跟开闭区间有关.
看到 log n + 有序排列 时, 可以想到二分查找

左闭右闭 [1, 1]:  
left = right 是有意义的, 所以在比较left和right时可以用 <= or >=
同样因为right被包含在内, 所以udpate right时, new right = middle - 1 or new left = middle + 1

左闭右开[1, 1): 
因为最右边的值不被包含在内, 要比较是否left = right 是没有意义的, 所以在比较left和right时, 只用 < or >. 
同样因为right不被包含在内, 所以update mid时, new right = middle or new left = middle + 1

提交错误:
第一次提交写错了: int left = 0 —— Python不需要声明变量是int类型, 跟Java语法搞混了
第二次提交写错了: nums.length() - 1 —— Python没有.length()这个语法, 可以用len(nums), 又跟Java语法搞混了. (我到底该用哪种语言刷题啊=. =)
第三次提交写错了: return nums[middle] —— return的应该是下标而不是下标对应的值, 没注意看题

菜鸡如我, 加油哇!

----------------------------------------------------------------------------------
附 Copy每日精华 —— 二分查找:
● 最重要的就是分类讨论好二分，二分看着好写边界 case 还是需要测试的哈
● 什么是区间不变量？ 比如 区间取左闭右闭的话 那么每次区间二分 范围都是新区间的左闭右闭  后面做判断时  要一直基于这个左闭右闭的区间
● 其实区间定义成开或者闭都没有什么关系  只是要明确每次收缩范围后 范围内的元素是哪些  注意会不会漏掉边界就好
● 大家需要注意二分的几种情况 
  ○ 当l = 0, r = n的时候因为r这个值我们在数组中无法取到,while(l < r) 是正确写法
  ○ 当l = 0, r = n - 1的时候因为r这个值我们在数组中可以取到,while(l <= r) 是正确写法 主要看能不能取到这个值
● 二分法有多种写法，末尾是开区间闭区间都可以解出寻找单个元素和寻找边界的题目，只需要注意相应的是l < r还是l <= r,每次取mid还是取mid加减一即可。建议理解后背熟一套模板，不要搞混。
● 其实二分还有很多应用场景，有着许多变体，比如说查找第一个大于target的元素或者第一个满足条件的元素，都是一样的，根据是否满足题目的条件来缩小答案所在的区间，这个就是二分的本质。另外需要注意，二分的使用前提：有序数组
● 二分的最大优势是在于其时间复杂度是O(logn)，因此看到有序数组都要第一时间反问自己是否可以使用二分。
● 关于二分mid溢出问题解答： 
  ○ mid = (l + r) / 2时，如果l + r 大于 INT_MAX(C++内，就是int整型的上限)，那么就会产生溢出问题（int类型无法表示该数）
  ○ 所以写成 mid = l + (r - l) / 2或者 mid = l + ((r - l) >> 1) 可以避免溢出问题
● 对于二进制的正数来说，右移x位相当于除以2的x几次方，所以右移一位等于➗2，用位运算的好处是比直接相除的操作快

===================================================================================

27. 移除元素
例题: Leetcode 27 Remove Element
https://leetcode.com/problems/remove-element/?envType=problem-list-v2&envId=nfedatxc

知识点: 
数组内存空间的地址是连续的
正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址
数组的元素是不能删的，只能覆盖

思路: 没学之前, 在两个for循环中跟target比较——暴力. 建立一个新数组用来储存符合条件的element——不符合题目中不再额外占用内存空间的要求.

学了快慢指针后的收获: 
慢指针得跟着快指针走, 所以把快指针放进for循环里, 而慢指针先被声明slow=0, 然后再根据与val的比较结果来决定要不要挪到下一位, 所以是在比较后再slow+=1.

提交错误:
第一次提交错误: for (fast = 0, fast < len(nums), fast++)...Python语法应该是 for fast in range(len(nums)) —— 又跟Java语法搞混了, 要不还是换Java刷吧 >. <
第二次提交错误: slow++, Python语法因该是 slow+=1 —— 又跟Java语法搞混了, 要不还是换Java刷吧 >. <

重温: rang()用法
range(start, stop) 的 右边界是开放的（不包含 stop），左边界是闭合的（包含 start)
1. 基本用法: range(n) 👉 从 0 到 n-1, 例子：
for i in range(5):
    print(i)
# 输出: 0 1 2 3 4

2. 指定起点和终点: range(a, b) 👉 从 a 到 b-1, 例子：
for i in range(2, 6):
    print(i)
# 输出: 2 3 4 5

3. 指定步长: range(a, b, step) 👉 从 a 开始，每次加上 step，直到 小于 b 为止, 例子：
for i in range(1, 10, 2):
    print(i)
# 输出: 1 3 5 7 9

4. 倒序（负步长): range(a, b, -step) 👉 从 a 开始，每次减去 step，直到 大于 b 为止, 例子：
for i in range(10, 0, -2):
    print(i)
# 输出: 10 8 6 4 2

左闭右开（取头不取尾）
步长可以正（递增）也可以负（递减）
如果只写一个数，就默认从 0 开始

=============================================================================================

977. 有序数组的平方

例题: Leetcode 977. 有序数组的平方
https://leetcode.com/problems/squares-of-a-sorted-array/description/?envType=problem-list-v2&envId=nfedatxc

学前想法:
把每个元素都算平方, 然后排序. O(n logn)

学后收获:
天呐, 我为什么不会提前观察数组元素们的特征? 平方之后一定是两边高中间凹!
天呐, 我为什么没有想到新建一个数组, 然后index从末尾开始记录较大值? 然后再把index往前挪!
是while left_index < right_index 还是 while left_index <= right_index? 即使left_index == left_index的时候, 也就是它们指向同一个index位置的时候, 这个index上的元素也需要被平方, 也需要更新到新的数组里面去. 
如果只有while left_index < right_index, 那么在left_index == left_index的时候就不进入循环了, 那么指向的同一index上的元素怎么办? 这个元素没有被平方也没有被更新到新数组里面去. 所以循环条件是while left_index <= right_index

重温:
Python里创建一个已知大小的新数组: new_array = [0] * len(nums)

第一次提交错误: while left < right, 没有写成 while left <= right


=============================================================================================

哇哈! 小菜鸡今天手撕了三道leetcode, 谁敢想呢?! 
一共67天, 7周, 我要每天一小庆, 每周一中庆, 每月一大庆, 67天后大庆特庆! 好的, 菜鸡加油, 明天继续!


