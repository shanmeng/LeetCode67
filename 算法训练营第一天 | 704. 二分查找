8/20/2025

算法训练营第一天 | 704. 二分查找

第一天! 第一次刷题, 一定要坚持, 67天之后回见!

文章: 
https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE
数组是存放在连续内存空间上的相同类型数据的集合
需要两点注意的是:
数组下标都是从0开始的
数组内存空间的地址是连续的
正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址
数组的元素是不能删的，只能覆盖

二维数组在内存的空间地址是连续的么？
不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。在Java中的解释看原文吧.


LeetCode 704.
https://leetcode.com/problems/binary-search/description/


没学之前的看题反应: 从左到右依次跟target值比大小...服了

学了二分法之后的收获: 区间边界的处理 —— 左闭右闭[ ] , 左闭右开[ ), 与之相对应的比大小是用 <= 和 >= 还是用 < 和 >. 
对开闭区间理解清楚了, 在比大小的时候脑子就不捣糨糊了, 不用再重复比较已经比较过的值了, 对于已经比较过的值, 记得在划新区间的时候把它刨除不然就又要在新区间里再比较一次.
当然, 怎么刨除跟开闭区间有关.

左闭右闭 [1, 1]:  
left = right 是有意义的, 所以在比较left和right时可以用 <= or >=
同样因为right被包含在内, 所以udpate right时, new right = middle - 1 or new left = middle + 1

左闭右开[1, 1): 
因为最右边的值不被包含在内, 要比较是否left = right 是没有意义的, 所以在比较left和right时, 只用 < or >. 
同样因为right不被包含在内, 所以update mid时, new right = middle or new left = middle + 1

第一次提交写错了: int left = 0 —— Python不需要声明变量是int类型, 跟Java语法搞混了
第二次提交写错了: nums.length() - 1 —— Python没有.length()这个语法, 可以用len(nums), 又跟Java语法搞混了
第三次提交写错了: return nums[middle] —— return的应该是下标而不是下标对应的值, 没注意看题

菜鸡如我, 加油哇!
